\section{Алгоритм Грэхема и анализ сложности}

\subsection{Алгоритм Грэхема}

Алгоритм Грэхема (известный также как \textquotedblleft{}сканирование по Грэхему\textquotedblright{})\footnotemark{} решает задачу построения выпуклой оболочки с помощью стека, сформированного из точек-кандидатов. Все точки входного множества заносятся в стэк, а затем точки, не являющиеся вершинами выпуклой оболочки, со временем удаляются из него. По завершении работы алгоритма в стеке остаются только вершины выпуклой оболочки в порядке их обхода против часовой стрелки.

\footnotetext{Описание алгоритма Грэхема, доказательство корректности алгоритма и анализ сложности: \cite{cormen}, Глава 33. Вычислительная геометрия. 33.3 Поиск выпуклой оболочки. Сканирование по Грэхему.}

Псевдокод процедуры, реализующей алгоритм Грэхема, приведён на странице 11. В качестве входных данных процедура принимает множество точек $A$. В процессе работы алгоритма используются функции стека: функция \textsc{Top}$(S)$, возвращающая точку на вершине стека S, функция \textsc{Nxt-To-Top}$(S)$, возвращающая точку, находящуюся на одну позицию ниже в стеке S, чем \textsc{Top}$(S)$. В результате процедура возвращает стек, содержащий вершины выпуклой оболочки в порядке обхода против часовой стрелки, если просматривать их в стеке снизу вверх.
В строке 4 процедуры выбирается точка $p_0$ с минимальной координатой $y$, при наличии нескольких таких точек -- с минимальной координатой $x$ из них. Эта точка является одной из вершин выпуклой оболочки. В строке 5 следует отсортировать остальные точки в порядке возрастания их полярных углов относительно точки $p_0$. Для этого можно воспользоваться любой сортировкой, используя при этом компаратор, сравнивающий точки по полярному углу относительно точки $p_0$. Если полярные углы двух точек совпадают, то, на этом этапе, можно упорядочить их по возрастанию расстояния от точки $p_0$. Затем среди точек с одинаковыми полярными углами необходимо оставить только максимально удалённую от $p_0$. Будем считать, что после этого в массиве осталось $m$ точек. Если $m = 0$, то мы получили вырожденный случай -- выпуклой оболочкой является единственная точка $p_0$. Если $m = 1$, то получили вырожденный случай, когда выпуклая оболочка является отрезком, в этом случае необходимо вернуть точки $p_0$ и $p_1$. Если же $m > 1$, то выпуклая оболочка является выпуклой фигурой, в этом случае необходимо обработать все точки $\left\langle p_1, p_2, \dots, p_m\right\rangle $. В процессе работы алгоритма точки добавляются в стек и удаляются оттуда, если обнаруживается, что точка не относится к выпуклой оболочке (образует поворот вправо или развернутый угол). В итоге в стеке остаются вершины, принадлежащие выпуклой оболочке в порядке обхода против часовой стрелки.

\newpage

\noindent Псевдокод процедуры сравнения двух точек (процедура возвращает true, если точка $p_a$ должна быть расположена раньше $p_b$ после сортировки):
\begin{algorithmic}[1]
	\Procedure{PolarAngleComp}{$p_a, p_b$}
		\State $v_1 = p_a - p_0;$ $v_2 = p_b - p_0$
		\If{\textsc{CrossProd}$(v_1, v_2) > 0$}
			\State \textbf{return} true
		\ElsIf{\textsc{CrossProd}$(v_1, v_2) < 0$}
			\State \textbf{return} false
		\Else
			\If {$\sqrt{({v_1}_x)^2+({v_1}_y)^2} < \sqrt{({v_2}_x)^2+({v_2}_y)^2}$}
				\State \textbf{return} true
			\Else
				\State \textbf{return} false
			\EndIf
		\EndIf
	\EndProcedure
\end{algorithmic}

\noindent Псевдокод процедуры функции векторного произведения:
\begin{algorithmic}[1]
	\Procedure{CrossProd}{$v_1, v_2$}
		\State \textbf{return} ${v_1}_x \cdot {v_2}_y - {v_1}_y \cdot {v_2}_x$
	\EndProcedure
\end{algorithmic}

Знак \textsc{CrossProd}$(v_1, v_2)$ определяется направлением поворота вектора $v_2$ относительно вектора $v_1$: если \textsc{CrossProd}$(v_1, v_2) > 0$, то вектор $v_2$ находится против часовой стрелки относительно $v_1$, если \textsc{CrossProd}$(v_1, v_2) < 0$ -- по часовой стрелке. Если \textsc{CrossProd}$(v_1, v_2)=0$ , то вектора $v_1$ и $v_2$ коллинеарны. Эти свойства векторного произведения позволяют определить направление поворота не вычисляя величину угла, например в строчке 3 функции \textsc{PolarAngleComp} \textsc{CrossProd}$(v_1, v_2) > 0$ будет означать, что вектор $(p_b-p_0)$ расположен относительно вектора $(p_a-p_0)$ против часовой стрелки, что, в свою очередь, значит, что полярный угол точки $p_a$ относительно точки $p_0$ меньше такого угла у точки $p_b$\footnotemark{}.

\footnotetext{Подробнее про векторное произведение векторов, определение направления поворота векторов и отрезков: \cite{cormen}, Глава 33. Вычислительная геометрия. 33.1 Свойства отрезков}

\newpage

\noindent Псевдокод процедуры, реализующей алгоритма Грэхема:
\begin{algorithmic}[1]
	\Procedure{GrahamScan}{$A$}
		\If{Множество точек $A$ -- пустое}
			\State \textbf{error} У пустого множества точек нет выпуклой оболочки
		\EndIf
		\State Пусть $p_0$ -- точка из множества $A$ с минимальной координатой $y$, или с минимальной координатой $x$ из таких точек, при наличии совпадений
		\State Пусть $\left\langle p_1, p_2, \dots, p_m\right\rangle $ -- остальные точки из множества A, отсортированные в порядке возрастания полярного угла, измеряемого против часовой стрелки отностительно точки $p_0$. Если у нескольких точек совпадают полярные углы, то из множества удаляются все эти точки, кроме одной, самой дальней от точки $p_0$
		\If{$m = 0$}
			\State \textbf{return} $\left\lbrace p_0\right\rbrace $
		\ElsIf{$m = 1$}
			\State \textbf{return} $\left\lbrace p_0, p_1\right\rbrace $
		\Else
			\State Пусть $S$ -- пустой стек
			\State \textsc{Push}$(p_0, S)$
			\State \textsc{Push}$(p_1, S)$
			\State \textsc{Push}$(p_2, S)$
			\For{$i = 3$ \textbf{to} $m$}
				\While{\textsc{CrossProd}$($\textsc{Top}$(S) - $\textsc{Nxt-To-Top}$(S), p_i - $\textsc{Top}$(S)) \le 0$ }
				\Comment{Угол, образованный точками \textsc{Nxt-To-Top}$(S)$, \textsc{Top}$(S)$ и $p_i$, не образует поворот влево}
					\State \textsc{Pop}$(S)$
				\EndWhile
				\State \textsc{Push}$(p_i, S)$
			\EndFor
			\State \textbf{return} $S$
		\EndIf
	\EndProcedure
\end{algorithmic}

\newpage

\subsection{Анализ сложности}

Пусть $n$ -- размер множества точек, поданного на вход алгоритма. Поиск точки $p_0$ выполняется однократным проходом по списку всех точек, соотвественно сложность этого этапа -- $O(n)$. Сложность этапа сортировки зависит от использованного алгоритма сортировки. Сравнение двух точек происходит за $O(1)$, поэтому в этом случае время работы сортировок: быстрая сортировка -- $O(n^2)$ в худшем случае, $O(n\lg n)$ -- ожидаемое время, в случае сортировки на АВЛ-дереве время работы сортировки гарантированно не превышает $O(n\lg n)$. Выбрать среди точек с одинаковыми углами точки, максимально удаленные от $p_0$, можно за $O(n)$, для этого необходимо среди точек с равным углом оставить лишь последнюю точку (так как все точки с равным углом расположены рядом и отсортированы по возрастанию расстояния от точки $p_0$). Оставшаяся часть алгоритма Грэхема выполняется за $O(n)$, это не трудно заметить, обратив внимание на то, что количество обращений к точкам \textsc{Top}$(S)$ и \textsc{Next-To-Top}$(S)$ происходит не более $O(n)$ раз.

Получается, что итоговая сложность алгоритма напрямую зависит от сложности использованной сортировки. В случае использования быстрой сортировки имеем ожидаемое время работы $O(n\lg n)$ и $O(n^2)$ в худшем случае. А при использовании AВЛ-дерева для сортировки мы имеем гарантированную сложность $O(n\lg n)$.

\newpage
